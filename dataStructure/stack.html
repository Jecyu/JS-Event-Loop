<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>栈 | JS 事件循环原理与异步机制解析</title>
    <meta name="description" content="Analysis vue.js deeply">
    <link rel="icon" href="/JS-Event-Loop/logo.png">
  <link rel="manifest" href="/JS-Event-Loop/manifest.json">
  <meta name="theme-color" content="#3eaf7c">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <link rel="apple-touch-icon" href="/JS-Event-Loop/icons/apple-touch-icon-152x152.png">
  <link rel="mask-icon" href="/JS-Event-Loop/icons/safari-pinned-tab.svg" color="#3eaf7c">
  <meta name="msapplication-TileImage" content="/icons/msapplication-icon-144x144.png">
  <meta name="msapplication-TileColor" content="#000000">
    
    <link rel="preload" href="/JS-Event-Loop/assets/css/0.styles.4bd8d34c.css" as="style"><link rel="preload" href="/JS-Event-Loop/assets/js/app.25665c49.js" as="script"><link rel="preload" href="/JS-Event-Loop/assets/js/2.83f650ae.js" as="script"><link rel="preload" href="/JS-Event-Loop/assets/js/4.d59dfcd1.js" as="script"><link rel="prefetch" href="/JS-Event-Loop/assets/js/10.af646ce3.js"><link rel="prefetch" href="/JS-Event-Loop/assets/js/11.7ef8ca1c.js"><link rel="prefetch" href="/JS-Event-Loop/assets/js/12.ba4224e9.js"><link rel="prefetch" href="/JS-Event-Loop/assets/js/13.48b834c9.js"><link rel="prefetch" href="/JS-Event-Loop/assets/js/14.ed5ef665.js"><link rel="prefetch" href="/JS-Event-Loop/assets/js/15.3452cf13.js"><link rel="prefetch" href="/JS-Event-Loop/assets/js/16.1b045293.js"><link rel="prefetch" href="/JS-Event-Loop/assets/js/17.5bc32494.js"><link rel="prefetch" href="/JS-Event-Loop/assets/js/18.b07221de.js"><link rel="prefetch" href="/JS-Event-Loop/assets/js/19.118ef21f.js"><link rel="prefetch" href="/JS-Event-Loop/assets/js/20.800f0c9a.js"><link rel="prefetch" href="/JS-Event-Loop/assets/js/21.7b81fccf.js"><link rel="prefetch" href="/JS-Event-Loop/assets/js/22.646c166c.js"><link rel="prefetch" href="/JS-Event-Loop/assets/js/23.0ddf253d.js"><link rel="prefetch" href="/JS-Event-Loop/assets/js/24.8aa876da.js"><link rel="prefetch" href="/JS-Event-Loop/assets/js/25.16316a78.js"><link rel="prefetch" href="/JS-Event-Loop/assets/js/26.55bb5aea.js"><link rel="prefetch" href="/JS-Event-Loop/assets/js/3.00812dad.js"><link rel="prefetch" href="/JS-Event-Loop/assets/js/5.8c4f1e7d.js"><link rel="prefetch" href="/JS-Event-Loop/assets/js/6.815506cc.js"><link rel="prefetch" href="/JS-Event-Loop/assets/js/7.d76cce3f.js"><link rel="prefetch" href="/JS-Event-Loop/assets/js/8.82bb9e43.js"><link rel="prefetch" href="/JS-Event-Loop/assets/js/9.be7d99bc.js">
    <link rel="stylesheet" href="/JS-Event-Loop/assets/css/0.styles.4bd8d34c.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/JS-Event-Loop/" class="home-link router-link-active"><!----> <span class="site-name">JS 事件循环原理与异步机制解析</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="https://github.com/Jecyu/JS-Event-Loop/tree/master/examples" target="_blank" rel="noopener noreferrer" class="nav-link external">
  配套例子
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <a href="https://github.com/Jecyu/JS-Event-Loop" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="https://github.com/Jecyu/JS-Event-Loop/tree/master/examples" target="_blank" rel="noopener noreferrer" class="nav-link external">
  配套例子
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <a href="https://github.com/Jecyu/JS-Event-Loop" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>回顾硬核知识：栈和队列</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/JS-Event-Loop/dataStructure/" class="sidebar-link">介绍</a></li><li><a href="/JS-Event-Loop/dataStructure/stack.html" class="active sidebar-link">栈</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/JS-Event-Loop/dataStructure/stack.html#利用数组创建一个栈" class="sidebar-link">利用数组创建一个栈</a></li><li class="sidebar-sub-header"><a href="/JS-Event-Loop/dataStructure/stack.html#用栈解决问题" class="sidebar-link">用栈解决问题</a></li><li class="sidebar-sub-header"><a href="/JS-Event-Loop/dataStructure/stack.html#总结" class="sidebar-link">总结</a></li></ul></li><li><a href="/JS-Event-Loop/dataStructure/queue.html" class="sidebar-link">队列</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>说说 CPU 层面的运作</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/JS-Event-Loop/cpu/" class="sidebar-link">介绍</a></li><li><a href="/JS-Event-Loop/cpu/program-workflow.html" class="sidebar-link">CPU 是如何执行程序的</a></li><li><a href="/JS-Event-Loop/cpu/concept.html" class="sidebar-link">一些关键概念</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>谈谈浏览器背后的运行机制</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/JS-Event-Loop/browser/" class="sidebar-link">介绍</a></li><li><a href="/JS-Event-Loop/browser/multi-process.html" class="sidebar-link">浏览器是多进程的</a></li><li><a href="/JS-Event-Loop/browser/thread-relationship.html" class="sidebar-link">梳理浏览器内核中线程之间的关系</a></li><li><a href="/JS-Event-Loop/browser/render-process.html" class="sidebar-link">浏览器渲染流程</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>深入剖析 JS 事件循环原理</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/JS-Event-Loop/event-loop/" class="sidebar-link">介绍</a></li><li><a href="/JS-Event-Loop/event-loop/eventloop.html" class="sidebar-link">从 Event Loop 谈 JS 的运行机制</a></li><li><a href="/JS-Event-Loop/event-loop/eventloop-more.html" class="sidebar-link">Event loop 进阶：macrotask 与 microtask</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>Vue 异步更新策略：nextTick</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/JS-Event-Loop/vue-nextTick/" class="sidebar-link">介绍</a></li><li><a href="/JS-Event-Loop/vue-nextTick/reactive-object.html" class="sidebar-link">响应式对象</a></li><li><a href="/JS-Event-Loop/vue-nextTick/nextTick.html" class="sidebar-link">nextTick</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>问题</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/JS-Event-Loop/tip/" class="sidebar-link">介绍</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>参考资料</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/JS-Event-Loop/refs/" class="sidebar-link">Introduction</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="栈"><a href="#栈" class="header-anchor">#</a> 栈</h1> <p>栈是一种遵从<strong>后进先出</strong>（LIFO）原则的有序集合。新添加或待删除的元素都保存在栈的同一端，称作栈顶，另一端就叫栈底。在栈里，新元素都靠近栈顶，旧元素都接近栈底。</p> <p>在现实生活中也能发现很多栈的例子。例如，下图里的一摞书或者餐厅里叠放的盘子。</p> <p><img src="/JS-Event-Loop/assets/img/book.260d6860.jpg" alt=""></p> <h2 id="利用数组创建一个栈"><a href="#利用数组创建一个栈" class="header-anchor">#</a> 利用数组创建一个栈</h2> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// LIFO：只能用 push, pop 方法添加和删除栈中元素，满足 LIFO 原则</span>
<span class="token keyword">class</span> <span class="token class-name">Stack</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>items <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token comment">/**
   * @description 向栈添加元素，该方法只添加元素到栈顶，也就是栈的末尾。
   * @param {*} element 
   * @memberof Stack
   */</span>
  <span class="token function">push</span><span class="token punctuation">(</span><span class="token parameter">element</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>items<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>element<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token comment">/**
   * @description 从栈移除元素
   * @returns 移出最后添加进去的元素
   * @memberof Stack
   */</span>
  <span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>items<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token comment">/**
   * @description 查看栈顶元素
   * @returns 返回栈顶的元素
   * @memberof Stack
   */</span>
  <span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>items<span class="token punctuation">[</span><span class="token keyword">this</span><span class="token punctuation">.</span>items<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token comment">/**
   * @description 检查栈是否为空
   * @returns
   * @memberof Stack
   */</span>
  <span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>items<span class="token punctuation">.</span>length <span class="token operator">===</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token comment">/**
   * @description 返回栈的长度
   * @returns
   * @memberof Stack
   */</span>
  <span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>items<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token comment">/**
   * @description 清空栈元素
   * @memberof Stack
   */</span>
  <span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>items <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="用栈解决问题"><a href="#用栈解决问题" class="header-anchor">#</a> 用栈解决问题</h2> <p>栈的实际应用非常广泛（只要满足 LIFO 规则的算法都可以使用栈来解决问题）。在回溯问题中，它可以存储访问过的任务或路径、撤销的操作。Java 和 C# 用栈来存储变量和方法调用，特别是处理递归算法时，有可能抛出一个栈溢出异常。</p> <h3 id="利用栈解决十进制转二进制的问题"><a href="#利用栈解决十进制转二进制的问题" class="header-anchor">#</a> 利用栈解决十进制转二进制的问题</h3> <p>它的计算规则满足：先顺序求余数值，再从逆序获得值。</p> <p><img src="/JS-Event-Loop/assets/img/decimal-to-Binary.43b46e19.png" alt=""></p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">/**
 * 把十进制转换成基数为 2～36 的任意进制。
 * @param {*} decNumber 十进制
 * @param {*} base 基数
 */</span>
<span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">decimalToBinary</span><span class="token punctuation">(</span><span class="token parameter">decNumber<span class="token punctuation">,</span> base</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> remStack <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Stack</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">let</span> number <span class="token operator">=</span> decNumber<span class="token punctuation">;</span> <span class="token comment">// 十进制数字</span>
  <span class="token keyword">let</span> rem<span class="token punctuation">;</span> <span class="token comment">// 余数</span>
  <span class="token keyword">let</span> binaryString <span class="token operator">=</span> <span class="token string">''</span><span class="token punctuation">;</span>

  <span class="token keyword">while</span> <span class="token punctuation">(</span>number <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 当结果不为0，获得一个余数</span>
    rem <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">floor</span><span class="token punctuation">(</span>number <span class="token operator">%</span> base<span class="token punctuation">)</span><span class="token punctuation">;</span> 
    remStack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>rem<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 入栈</span>
    number <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">floor</span><span class="token punctuation">(</span>number <span class="token operator">/</span> base<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>remStack<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    binaryString <span class="token operator">+=</span> remStack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> binaryString<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="代码运行方式——调用栈"><a href="#代码运行方式——调用栈" class="header-anchor">#</a> 代码运行方式——调用栈</h3> <p>调用栈，表示函数或子例程像堆积木一样存放，以实现层层调用。
下面以一段 js 代码为例：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">Student</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">age<span class="token punctuation">,</span> name</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setName</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token function">setName</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> s <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token number">23</span><span class="token punctuation">,</span> <span class="token string">'Jonh'</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>上面这段代码运行的时候，首先调用 main 方法，里面需要生成一个 Student 的实例，于是又调用 Student 构造函数。在构造函数中，又调用到 setName 方法。</p> <p><img src="/JS-Event-Loop/assets/img/call-stack.6b365e96.png" alt="call stack"></p> <p>这三次调用像积木一样堆起来，就叫做“调用栈”。程序运行的时候，总是先完成最上层的调用，然后将它的值返回到下一层调用。直至完成整个调用栈，返回最后的结果。</p> <p>原理大概:</p> <ol><li>调用 main 方法，这个时候需要调用 Student 构造函数，把这个位置A作为 return 地址存入栈中。</li> <li>这个时候调用并进入 Student 构造函数内部，遇到 SetName() 方法，把这里的位置B 作为 return 地址存入栈中记录下来存入栈中。</li> <li>这时调用并进入 setName() 方法内部执行完毕后，之后从栈中拿出 B 地址，返回到 Student 函数内部继续执行。</li> <li>Student 函数执行完毕后，然后从栈中继续拿出 A 地址，进入到一开始的 main 函数内部执行，至此完毕。</li></ol> <p>查看附带例子：<code>examples/browser/01-call-stack.html</code></p> <h4 id="内存区域"><a href="#内存区域" class="header-anchor">#</a> 内存区域</h4> <p>程序运行的时候，需要内存空间存放数据。一般来说，系统会划分出两种不同的内存空间：一种是叫做 <code>stack</code> (栈)，另一种叫做 <code>heap</code>（堆）。一般来说，每个线程分配一个 <code>stack</code>，每个进程分配一个 <code>heap</code>，也就是说，<code>stack</code> 是线程独占的，<code>heap</code> 是现场共享的。此外，<code>stack</code> 创建的时候，大小是确定的，数据超过这个带下，就发生 <code>stack overflow</code> 错误。而 <code>heap</code> 的大小是不确定的，需要的话可以不断增加。</p> <p>栈由系统自动分配释放，存放函数的参数值合局部变量的值等。</p> <p>堆一般由程序员分配释放，若程序员不释放，程序结束时可能由 OS 回收。</p> <p>根据上面这些区别，数据存放的规则是：只要是局部的、占用空间确定的数据，一般都存放在 <code>stack</code> 里面，否则就放在 <code>heap</code> 里面。请看下面这段代码：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">Method1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span>
  <span class="token keyword">let</span> b <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> cls1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">class1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>上面的代码的 Method1 方法，共包含了三个变量：a，b 和 cls1。其中，i 和 y 的值是整数，内存占用空间是确定，而且是局部变量，只用在 Methods1 区块之内，不会用于区块之外。cls1 也是局部变量，但是类型为指针变量，指向一个对象的实例。指针变量占用的大小是确定的（这里存储的是地址），但是对象实例以目前的信息无法确知所占用的内存空间大小。</p> <p>这三个变量和一个对象实例在内存中的存放方式如下：</p> <p><img src="/JS-Event-Loop/assets/img/memory-space.aad54602.png" alt=""></p> <p>从上图可以看到，<code>a、b</code>和 <code>cls1</code> 都存放在 <code>stack</code>，因为它们占用内存空间都是确定的，而且本身也属于局部变量。但是，<code>cls1</code> 指向的对象实例存放在 <code>heap</code>，因为它的大小不确定。</p> <p>接下来的问题是，当 Method1 方法运行结束，会发生什么事？</p> <p>回答是整个 <code>stack</code> 被清空，a、b 和 cls1 这三个变量消失，因为它们是局部变量，区块一旦运行结束，就没必要再存在了。而 <code>heap</code> 之中的哪个对象实例继续存在，直到系统的垃圾清理机制（<code>garbage collector</code>）将这块内存回收。因此，一般来说，内存泄漏都发生在 <code>heap</code>，即某些内存空间不再被使用了，却因为种种原因，没有被系统回收。</p> <h3 id="综合分析一段-javascript-代码（内存区域-调用栈）"><a href="#综合分析一段-javascript-代码（内存区域-调用栈）" class="header-anchor">#</a> 综合分析一段 JavaScript 代码（内存区域+调用栈）</h3> <p>递归算法中，变量和方法是如何入栈的，为什么有爆栈？或者说栈溢出？</p> <ol><li><strong>调用栈</strong></li></ol> <p>每当一个函数被一个算法调用时，该函数会进入调用栈的顶部。当使用递归时，每个函数调用都回堆叠在调用栈的顶部，这是因为每个调用都可能依赖前一个调用的结果。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">/**
 * 递归阶乘
 * @param {*} n 
 */</span>
<span class="token keyword">function</span> <span class="token function">factorial</span><span class="token punctuation">(</span><span class="token parameter">n</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">trace</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">===</span> <span class="token number">1</span> <span class="token operator">||</span> n <span class="token operator">===</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 基线条件</span>
    <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> n <span class="token operator">*</span> <span class="token function">factorial</span><span class="token punctuation">(</span>n <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 递归调用</span>
<span class="token punctuation">}</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'factorial(3) :'</span><span class="token punctuation">,</span> <span class="token function">factorial</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>我们可以用浏览器看到调用栈的行为，如下图所示</p> <p><img src="/JS-Event-Loop/assets/img/call-stack-browser.08677a05.png" alt=""></p> <p>通过 debugger 可以看到每一次函数在推入栈，直接当 factorial(1) 被调用时，我们能在控制台得到下面的结果。</p> <div class="language- extra-class"><pre class="language-text"><code>factorial	@	02-Factorial.js:20
factorial	@	02-Factorial.js:25
factorial	@	02-Factorial.js:25
</code></pre></div><p>当 factorial(1) 返回 1 时，调用栈开始弹出调用，返回结果，直到 3 * factorial(2) 被计算。</p> <ol><li><strong>JavaScirpt 调用栈大小的限制</strong></li></ol> <p>如果忘记加上用以停止函数递归调用的基线条件，会发生什么呢？递归并不会无限地执行下去，浏览器会抛出错误，也就是所谓的栈溢出错误。（stack overflow error）。</p> <p>每个浏览器都有自己的上限，可用以下代码测试。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 测试浏览器的栈溢出错误，即超过最大调用栈</span>
<span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token keyword">function</span> <span class="token function">recursiveFn</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  i<span class="token operator">++</span><span class="token punctuation">;</span>
  <span class="token function">recursiveFn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">try</span> <span class="token punctuation">{</span>
  <span class="token function">recursiveFn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span>ex<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'i = '</span> <span class="token operator">+</span> i <span class="token operator">+</span> <span class="token string">'error: '</span> <span class="token operator">+</span> ex<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>在 Chrome 78 中，该函数执行了 15689 次，之后抛出错误 RangeError: Maximum call stack size exceeded（超限错误：超过最大调用栈大小）。</p> <p>附带例子：<code>examples/browser/05-stack-overflow.html</code></p> <p>解决方案是可以使用尾递归优化。</p> <h2 id="总结"><a href="#总结" class="header-anchor">#</a> 总结</h2> <p>通过本小节，我们学习了栈这一数据结构的相关知识。我们用代码自己实现了栈，也讲解了栈的多种用处，其中执行栈跟JS运行机制密切相关。下一节将要学习队列，它和栈有很多相似之处，但是有个重要的区别，队列里的元素不遵循后进先出的规则。</p></div> <footer class="page-edit"><div class="edit-link"><a href="https://github.com/Jecyu/JS-Event-Loop/edit/master/docs/dataStructure/stack.md" target="_blank" rel="noopener noreferrer">在 GitHub 上编辑此页</a> <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></div> <div class="last-updated"><span class="prefix">上次更新:</span> <span class="time">11/29/2019, 5:51:25 PM</span></div></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/JS-Event-Loop/dataStructure/" class="prev router-link-active">介绍</a></span> <span class="next"><a href="/JS-Event-Loop/dataStructure/queue.html">队列</a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/JS-Event-Loop/assets/js/app.25665c49.js" defer></script><script src="/JS-Event-Loop/assets/js/2.83f650ae.js" defer></script><script src="/JS-Event-Loop/assets/js/4.d59dfcd1.js" defer></script>
  </body>
</html>
