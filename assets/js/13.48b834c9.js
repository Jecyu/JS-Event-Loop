(window.webpackJsonp=window.webpackJsonp||[]).push([[13],{244:function(t,v,e){"use strict";e.r(v);var _=e(0),o=Object(_.a)({},(function(){var t=this,v=t.$createElement,_=t._self._c||v;return _("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[_("h1",{attrs:{id:"从-event-loop-谈-js-的运行机制"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#从-event-loop-谈-js-的运行机制"}},[t._v("#")]),t._v(" 从 Event Loop 谈 JS 的运行机制")]),t._v(" "),_("p",[t._v("单线程 == 一个调用栈 == one thing at a time（一个时间点做一件事）")]),t._v(" "),_("p",[t._v("我们知道 JS 引擎是单线程的，这里会用到上文中的几个概念：")]),t._v(" "),_("ul",[_("li",[t._v("JS 引擎线程")]),t._v(" "),_("li",[t._v("事件触发线程")]),t._v(" "),_("li",[t._v("定时触发器线程")])]),t._v(" "),_("p",[t._v("然后再理解一个概念：")]),t._v(" "),_("ul",[_("li",[t._v("JS 分为同步任务和异步任务。")]),t._v(" "),_("li",[t._v("同步任务都在主线程上执行难，形成一个"),_("code",[t._v("执行栈")]),t._v("。")]),t._v(" "),_("li",[t._v("主线程之外，"),_("strong",[t._v("事件触发线程")]),t._v("管理着一个"),_("code",[t._v("任务队列")]),t._v("，只要异步任务有了运行结果，就在"),_("code",[t._v("任务队列")]),t._v("之中放置一个事件。")]),t._v(" "),_("li",[t._v("一旦"),_("code",[t._v("执行栈")]),t._v("中的所有同步任务执行完毕（此时 JS 引擎空闲），系统就会读取"),_("code",[t._v("任务队列")]),t._v("，将可运行的异步任务添加到可执行栈中，开始执行。")])]),t._v(" "),_("p",[_("img",{attrs:{src:e(74),alt:"event-loop-1"}})]),t._v(" "),_("p",[t._v("看到这里，应该可以理解了：为什么有时候 setTimeout 推入的事件不能准时执行？因为可能在它推入到事件列表时，主线程还不空闲，正在执行其他代码，所以自然有误差。")])])}),[],!1,null,null,null);v.default=o.exports},74:function(t,v,e){t.exports=e.p+"assets/img/event-loop-1.2aaf1500.png"}}]);