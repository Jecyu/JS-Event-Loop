(window.webpackJsonp=window.webpackJsonp||[]).push([[16],{220:function(t,e,r){t.exports=r.p+"assets/img/vue-reactive.b13be2ac.jpg"},254:function(t,e,r){"use strict";r.r(e);var s=r(0),a=Object(s.a)({},(function(){var t=this,e=t.$createElement,s=t._self._c||e;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"响应式对象"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#响应式对象"}},[t._v("#")]),t._v(" 响应式对象")]),t._v(" "),s("ul",[s("li",[t._v("依赖收集\n"),s("ul",[s("li",[t._v("函数调用流程： "),s("code",[t._v("initSate -> observe -> observer -> defineReactive")]),t._v(" "),s("ul",[s("li",[t._v("收集依赖的目的时为了当这些响应式数据发生变化，触发它们的 setter 的时候，能知道应该通知哪些订阅者去做相应的逻辑处理，我们把这个过程叫派发更新。")])])])])]),t._v(" "),s("li",[t._v("派发更新\n"),s("ul",[s("li",[t._v("实际上就是当数据发生变化的时候，触发 setter 逻辑，把在依赖过程中订阅的所有观察者，也就是 watcher ，都触发它们的 update 过程，这个过程又利用了队列（watcher 队列）做了进一步优化，在 nextTick 后执行所有 watcher 的 run，最后执行它们的回调函数。")])])])]),t._v(" "),s("p",[s("img",{attrs:{src:r(220),alt:""}})])])}),[],!1,null,null,null);e.default=a.exports}}]);